# 区块链

## 微观区块链

### 概念

区块链最底层的数据结构：按时间顺序将数据区块通过哈希指针的方式连接起来的一个链表。**哈希指针**是区块链里最常用的数据结构，其实就是一串数据的**哈希值**，我们知道，一串数据的哈希值就是这串数据的**指纹/摘要**，因此就可以用这个哈希值来指向这串数据![img](http://keeganlee.me/Blockchain/_image/2018-02-07-12-50-00.jpg)

区块链里的每一个区块都有对应本区块的哈希指针，而除了创世区块（即第一个区块）之外，其他每个区块都存储了前一个区块的哈希指针，从而形成如下所示的一个链条，即区块链：

![img](http://keeganlee.me/Blockchain/_image/blockchain.png)

这样的数据结构可以保证数据无法篡改，因为一旦篡改了任何区块的数据，对应的哈希指针就会出错，因此一旦有恶意篡改就能校验到。数据的无法篡改也是区块链本质上最核心的一个特性。

### 不可篡改性

![img](http://keeganlee.me/Blockchain/_image/block.png)

**Tx0 ~ Tx3** 表示每一笔交易数据，**Hash0** 则是 **Tx0** 这笔交易数据的哈希指针，**Hash01** 则是 **Hash0 + Hash1** 的哈希指针，这样层层叠加上去，得到最后的 **Root Hash**。从图中也可以看出，从Hash0 到 Root Hash 是一个三层的二叉树，由于这颗树的所有节点都是 Hash 值，所以也称为 Hash Tree，但更专业的名称叫 **Merkle Tree**。不过 Merkle Tree 不一定是二叉树，也可以是多叉树。Merkle Tree 的叶子节点（即Hash0 ~ Hash3）是数据块的 Hash 值，而非叶子节点的 value 则是根据下面的叶子节点的 Hash 值串联起来后再计算 Hash 得出的。通过 Merkle Tree 结构，底层的每一笔交易也都无法篡改，一旦篡改，Root Hash 就会不一致。

### 简化校验

![img](http://keeganlee.me/Blockchain/_image/2018-02-20-23-20-02.jpg)

只要校验从 Tx3 到 Root Hash 的分支 Hash 值即可，如图所示，计算 Tx3 的 Hash值得到 Hash3，再结合 Hash2，计算出 Hash23，再拼上 Hash01 计算出 Merkle Root，只要计算出来的 Merkle Root 和实际存储的 Root Hash 一致，则表明该该笔交易是有效的。	

## 宏观区块链

宏观上的区块链就是一种基础协议，而不是指代具体的技术。作为一种基础协议，有几个基本特征是必备的，那就是**分布式存储、P2P 网络和共识机制**，当然，还有微观层面的**不可篡改且可追踪溯源**，如果不具备这几个特征，哪怕只缺了一个，都不能称为区块链。

#### 分布式存储

前面我们已经了解到，区块链最底层的数据结构就是一种哈希链条，是用来存储数据的，当然，采用哪种具体的数据库来存储区块链数据则是由各区块链的开发团队自己决定的，比如，比特币和以太坊就选择了 LevelDB。分布式存储，就是说，区块链数据的存储是分布式的，也因此很多人将区块链称为分布式数据库，但区块链的分布式存储与传统的分步式存储有所不同。传统的分布式存储是将数据分散存储到多个服务器上，每个存储服务器上的数据只是全量数据的一部分。但区块链的分布式存储，每个数据节点存储的都是全量数据。不过，区块链的节点可分为**全节点**和**轻节点**，全节点存储了整条区块链的所有数据，包括所有区块头和所有交易数据，而轻节点则只存储了整条链的所有区块头。那如果要在轻节点查询某笔交易的有效性，就需要转去全节点查询了，那节点之间如何通信呢？这就涉及到第二个基本特征——**P2P 网络**。另外，既然是分布式存储，那就还要解决数据一致性的问题，就这涉及到第三个基本特征——**共识机制**。

#### P2P 网络

即**对等网络**，也称**点对点网络**或端对端网络，是区块链系统中不同节点之间通信的方式，也是一种分布式的网络结构。通过 P2P 网络，不同节点之间可以直接交互，而且彼此连接的每个节点都处于对等的地位。每个节点既充当服务器，为其他节点提供服务，同时也享用其他节点提供的服务。那么，既然每个节点的地位都是对等的，那不同节点之间出现分歧时，要如何达成一致共识呢？这也是共识机制所解决的问题。

#### 共识机制

是区块链的一个核心特征，是保证区块链系统在分布式架构下的一致性方案。要理解共识机制，我们先来了解下交易写入区块链的简要过程。首先，当你在某个节点发起一笔交易时，比如从地址 A 转 0.1 个 BTC 到地址 B，该节点接收到交易信息后就对其进行校验，如果地址 A 上的未消费 BTC 的余额大于 0.1 个则可认为该笔交易是合法的，那就会将这笔交易信息放入本节点的 pending 池（待写入区块的交易池），并将这笔交易信息**广播**给其他已建立连接的节点，其他节点接收到交易信息后也做同样的校验并广播，当其中某个节点获得记账权时则可将它**当前的区块（包含上面那笔交易）**写入本节点存储的区块链中并将这个区块广播出去，其他大部分节点校验了此区块为有效，也同样写入它们自己存储的区块链中，这样，你的这笔交易就算真正写入到区块链中了。那如果你同时向 B 和 C 地址分别转 0.1 个 BTC，但你的地址 A 的未消费 BTC 余额只有 0.1 个的情况下，假设有些节点可能只接收到转给 B 的交易，而有些节点则只接收到转到 C 的交易，这些节点分别校验通过并写入了它们的 pending 池，但最终只有其中一笔交易能被写入区块链，取决于哪个节点先获得记账权并被其他大部分节点所接受，而另一笔交易就算已经被那些将其写入了 pending 池的节点所接受，其他节点再次校验后也不会通过。所以，一笔交易是否合法，以及一个新增区块是否有效，不是由某一个节点说了算，而是需要经过多数节点的最终一致共识。

#### 核心目的

**构建一个自信任系统**

## 漫谈共识机制

### 比特币共识机制

比特币的分布式共识是由网络节点的 4 种独立过程相互作用而达成的

#### 每个全节点基于一份长长的判断标准清单对每个交易进行独立验证

1. 每个节点收到每一个交易之后，都会先根据一份很长的判断标准清单对该交易进行有效性校验
2. 节点就会将该交易放入本地的**交易池**（或称**内存池**），并将该交易广播给其他相邻的节点。如果没通过验证，则会废弃该交易，也不会将其广播出去。其他节点类似。
3. 所以，理论上来说，无效的交易一开始就会被废弃，而有效的交易最终会到达整个网络所有节点，并被每个全节点所保存，即全网达成了 “该交易有效” 的共识

#### 每个挖矿节点独立将多个交易打包进新区块，通过完成 POW 算法的验算

1. 经过一段时间，每个节点的交易池里会收集到很多有效但还未确认的交易，这些交易会组装成一颗 **Merkle Tree**，得到 **Merkle Root**，再结合区块头的其他 5 个字段——**Version、Pre Block、Times、Difficulty、Nonce**，总共 6 个字段合在一起经过**两次 SHA256 计算**得到区块哈希值；
2. 一个有效的区块要求其哈希值必须小于 Difficulty 难度值。挖矿其实就是通过修改参数的值而不断计算区块哈希值，直到计算出符合难度要求的哈希值。一般是通过修改 Nonce 值来计算区块哈希值，其他 5 个字段基本是不变的；
3. 由于哈希函数的特性，难度值越大，理论上计算出符合要求的哈希值所需的计算量就越大（如抛骰子）。从统计学来说，一定的难度值可以推算出概率上对应所需的计算次数，也就是 “工作量”，所以，只要你达到了难度要求，也就间接证明你付出了对应的工作量，这就是**工作量证明**。

#### 每个节点独立验证新区块并组装进区块链

当其他节点收到此区块时，也会各自独立验证该区块是否有效

标准：验证标准清单，包括但不限于校验引用的上一个区块是否正确、难度值是否符合标准、区块哈希是否真的符合难度要求、Coinbase 交易中的挖矿奖励是否多于应得的、整个区块的每笔交易是否都是有效的等等。

其中，难度值是有标准的计算公式的，每个节点都会根据标准公式独立计算实际的难度。所以，矿工如果不按照标准而自己设置一个较低的难度，在其他节点是无法通过的。

同样，挖矿奖励也是有标准公式的，所以，如果矿工给自己奖励过多的比特币，在其他节点也是同样无法通过的。

#### 每个节点独立选择最长链，即在 POW 机制下累计工作量最多的那条链

由于所有节点同时在挖同一个区块，就有可能会出现多个节点同时挖出了同个区块，并都将各自挖到的区块广播到其他节点。

示例：假设有两个节点同时挖出了新区块，分别为区块 N1 和 N2，它们的上一个区块都是 P。有些节点会先收到 N1，它们会将 N1 先组装进它们本地的区块链，也称为主链。但之后不久，这些节点也会收到 N2，这时候，它们会将 N2 放入备选链。若其他节点先收到 N2 再收到 N1，则 N2 在它们的主链上，而 N1 在它们的备选链上。这时候，整个区块链暂时就分成了两个分叉，而要打破这种局面，就要看**下一个**生成的区块是基于 N1 还是 N2 了。如果下一个区块是基于 N1，自然N1 的这条链就变成了最长链，也是累计工作量最多的链。那么，那些将 N2 链设为主链的节点就会根据实际情况自己选择将 N1 链改为主链，而 N2 将成为**孤块**而被废弃。

## 去中心化：可信与验证

### 非对称加密运行机制

在非对称加密中，使用两种密钥，分别是公钥和私钥。对于一个用户而言，他有一对公钥和私钥。这两把钥匙不相同。

但是，这两把密钥有这样的特性：

- **情况一：私钥加密的信息，只能用公钥来解密；**
- **情况二：用公钥加密的信息，只能用私钥来解密。**

由于加密和解密时，所用到的密钥是不同的，所以，我们把这种加密机制叫做非对称加密。

### 使用非对称加密来实现信息传输的安全性：去中心化的可信

![preview](https://pic1.zhimg.com/v2-7f7a4fb585eb798fdcda7d529d30fa1e_r.jpg)

### 用非对称加密来实现信息发布者身份的验证：去中心化的验证

![preview](https://pic2.zhimg.com/v2-a2392347dc9fc4280b52f249c5866bbe_r.jpg)

### 非对称加密与数字签名同时使用，实现可信与验证

![preview](https://pic4.zhimg.com/v2-3523039999c4c0e7d3cdced309f8d173_r.jpg)

#### 具体操作

- **对A而言：**

- - 需要的工具：**A的私钥，B的公钥**

  - 具体操作：

  - - 对要发送的信息，首先通过**A的私钥加密**，得到Message-E-A。
    - 然后对Message-E-A**用B的公钥加密**，得到最终密文Message-E-A-B。

- **对B而言：**

- - 需要的工具：**A的公钥，B的私钥**

  - 具体操作：

  - - 收到的密文是Message-E-A-B.首先，**用B的私钥来进行解密**，得到Message-E-A。

    - 那么，怎么确定这个信息的来源呢？

      如果**用A的公钥来解密**，可以得到明文Message，则可以确定该信息是A发送的。否则，就不是A发送的。
